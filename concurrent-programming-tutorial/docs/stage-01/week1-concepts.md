# Week 1 理论与概念纲要：并发动机与基础模型

本阶段聚焦「为什么需要并发」「并发是怎么运行的」「代价是什么」。目标是建立心智模型，后续实验有参照系。

## 1. 并发 vs 并行
- 并发：在时间片上交错处理多个任务，核心是任务切换与协调；单核也可并发。
- 并行：多个任务在同一时间真正同时执行，需要多核/多 CPU。
- 设计含义：并发关注正确性与调度；并行关注吞吐与扩展。

## 2. 线程与进程模型
- 进程：资源隔离单元，拥有独立虚拟地址空间。
- 线程：调度与执行单元，共享进程资源（堆、静态区），私有栈/寄存器/程序计数器。
- Java 线程映射：HotSpot 使用 1:1 模型（Java 线程 ≈ OS 线程）。
- 线程状态：NEW、RUNNABLE、BLOCKED、WAITING、TIMED_WAITING、TERMINATED。
- 生命周期：创建→就绪→运行→阻塞/等待→运行→终止。

## 3. 上下文切换成本
- 概念：从一个线程切到另一个线程，保存/恢复 CPU 寄存器、程序计数器、栈指针、TLB 等。
- 触发：时间片用完、线程阻塞（锁、I/O、sleep）、高优先级抢占、系统调用。
- 成本来源：缓存失效（L1/L2/L3）、TLB 刷新、调度器开销、内核态/用户态切换。
- 启示：线程不是越多越好；适配 CPU 核数与任务类型，减少无谓切换。

## 4. CPU 缓存与内存层次概览
- 层次：寄存器 < L1 < L2 < L3 < 内存 < 磁盘/网络，延迟差距巨大。
- 缓存行（cache line）：常见 64 字节，CPU 以缓存行为粒度与内存交互。
- 伪共享（false sharing）：不同线程修改同一缓存行内的不同变量会频繁失效，导致性能下降。
- 启示：理解缓存行为是认识可见性与重排的前提。

## 5. Java 线程 API 基础
- 创建：继承 `Thread` 或实现 `Runnable`/`Callable`，用 `new Thread(runnable).start()` 启动。
- 停止：避免 `stop`，使用可见的标志位或中断机制；`interrupt` 设置中断标志，阻塞方法抛 `InterruptedException`。
- 常用方法：`sleep`、`join`、`yield`（不保证释放时间片）、`setName`（便于日志与诊断）。

## 6. 并发的主要问题类型
- 竞态条件（Race Condition）：结果依赖不可控的执行时序。
- 可见性问题：线程未看到最新写入（缓存/重排导致）。
- 原子性问题：复合操作被打断（读-改-写非原子）。
- 有序性问题：指令重排破坏预期顺序。
- 阻塞与死锁：循环等待资源；活锁/饥饿：不停重试或长期得不到执行。

## 7. 测量与观察基础
- 打印线程名与时间戳，观察交错输出。
- 粗粒度测量：`System.nanoTime()` 记录片段耗时，估算切换开销趋势（非绝对值）。
- 线程 dump（`jstack`/`jcmd Thread.print`）：查看状态、持锁、等待关系（本周可先了解命令用途）。

## 8. 本周实验要点（对应 plan.md）
- 最小并发示例：多个线程打印标识，确认线程创建/调度行为。
- 上下文切换示例：单线程 vs 多线程循环计数的耗时对比，感知切换成本。
- 共享变量错乱示例：无同步的计数器出现丢失更新，观察竞态现象。

## 9. 小结与复盘提示
- 能清晰区分并发/并行与线程/进程差异。
- 能口述线程状态与典型状态迁移。
- 知道上下文切换为什么有成本，何时需要控制线程数。
- 对缓存行与伪共享有直觉，为后续 JMM/可见性学习打下基础。
